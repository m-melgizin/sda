# Программирование, алгоритмы и структуры данных

## 6. Сортировки. Нижняя теоретико-информационная оценка сложности задачи сортировки. Алгоритмы сортировки вставками, пузырьком, быстрая сортировка, сортировка слиянием. Оценка сложности.

### **6.1. Нижняя теоретико-информационная оценка сложности задачи сортировки**

**Сортировка сравнениями** (**Comparison sort**) – алгоритм сортировки, который совершает операции сравнения элементов, но никак не использует их внутреннюю структуру.

___

**Теорема о нижней оценке для сортировки сравнениями**

В худшем случае любой алгоритм сортировки сравнениями выполняет $\Omega(n \log n)$ сравнений, где $n$ – число сортируемых элементов.

**Доказательство**

Любому алгоритму сортировки сравнениями можно сопоставить дерево. В нем узлам соответствуют операции сравнения элементов, ребрам – переходы между состояниями алгоритма, а листьям – конечные перестановки элементов (соответствующие завершению алгоритма сортировки). Необходимо доказать, что высота такого дерева для любого алгоритма сортировки сравнениями не меньше чем $\Omega(n \log n)$, где $n$ – количество элементов.

Ограничимся рассмотрением сортировки перестановок $n$ элементов. При сравнении некоторых двух из них, существует два возможных исхода ($a_i \leqslant a_j$ и $a_i > a_j$), значит, каждый узел дерева имеет не более двух сыновей. Всего существует $n!$ различных перестановок $n$ элементов, значит, число листьев нашего дерева не менее $n!$ (в противном случае некоторые перестановки были бы не достижимы из корня, а, значит, алгоритм не правильно работал бы на некоторых исходных данных).

Докажем, что двоичное дерево с не менее чем $n!$ листьями имеет глубину $\Omega(n \log n)$. Легко показать, что двоичное дерево высоты $h$ имеет не более чем $2^h$ листьев. Значит, имеем неравенство $n! \leqslant l \leqslant 2^h$, где $l$ – число листьев. Прологарифмировав его, получим:

$$h \geqslant \log_2 n! = \log_2 1 + \log_2 2 + \ldots + \log_2 n > \dfrac{n}{2} \log_2 \left(\dfrac{n}{2}\right) = \dfrac{n}{2}(\log_2 n - 1) = \Omega (n \log n)$$

Итак, для любого алгоритма сортировки сравнениями, существует такая перестановка, на которой он выполнит $\Omega(n \log n)$ сравнений.

___

**Следствия**

**Утверждение: Пирамидальная сортировка и сортировка слиянием являются асимптотически оптимальными  сортировками сравнением.**

**Доказательство**

Верхние границы $O(n \log n)$ времени работы пирамидальной сортировки и сортировки слиянием совпадают с нижней границей $\Omega(n \log n)$ для наихудшего случая из теоремы о нижней границе для сортировки сравнениями.

___

**Утверждение: Любая сортирующая сеть с $n$ нитями имеет размер $\Omega(n \log n)$.**

**Доказательство**

Каждый компаратор реализует одно сравнение двух элементов. Поэтому сортирующая сеть является алгоритмом сортировки, который основан на сравнениях, при чем количества компараторов и сравнений в этом алгоритме совпадают. Значит, их $\Omega(n \log n)$

___

**Утверждение: Любая сортирующая сеть с $n$ нитями имеет глубину $\Omega(\log n)$.**

**Доказательство**

На каждом слое может быть не более $\dfrac{n}{2}$ компараторов, так как внутри одного слоя гнезда компаратора крепятся к разным нитям, а их $n$.

Пусть $d$ – количество слоев этой сети. Тогда количество компараторов $k \leqslant \dfrac{n}{2} \cdot d$

Теорема утверждает, что количество сравнений этого алгоритма (то есть количество компараторов) $k = \Omega(n\log n)$.

Это означает, что найдется такая константа $c$, что $k \geqslant c \cdot n \log n$.
Таким образом 
$$c \cdot n \log n \leqslant k \leqslant \dfrac{n}{2} \cdot d \Rightarrow c \cdot n \log n \leqslant \dfrac{n}{2}\cdot d \Rightarrow 2c\log n \leqslant d \Rightarrow d = \Omega(\log n)$$

___

**Утверждение: Не существует алгоритма добавления элемента в упорядоченный массив с сохранением порядка, за истинное время $\mathcal{o}(\log n)$, где $n$ – количество элементов в массиве.**

**Доказательство**

Допустим, есть такой алгоритм. Тогда создадим пустой массив и будем последовательно добавлять в него элементы массива, который хотим отсортировать. В итоге на выходе алгоритма получим отсортированный массив.

Тогда сравнений будет $\mathcal{o}(\log 1 + \log 2 + \ldots + \log{(n-1)}) = \mathcal{o}(n\log n)$. Но теорема утверждает, что их должно быть $\Omega(n\log n)$.

___

**Утверждение: Не существует структуры данных, которая одновременно поддерживает добавление элементов и извлечение минимума за амортизированное время $\mathcal{o}(\log n)$.**

**Доказательство**

Если бы такая структура существовала, то с её помощью можно было бы отсортировать все элементы за амортизированное время $\mathcal{o}(n \log{n})$ – добавить все элементы,
а затем извлечь минимальный $n$ раз. Можно заметить, что теореме даётся оценка на истинную нижнюю границу, а в данном утверждении фигурирует амортизированное время.

Но этот факт не является проблемой, так как амортизированное время $\mathcal{o}(\log n)$ на одну операцию в случае $n$ операций даст суммарное истинное время $\mathcal{o}(n \log n)$.

___


### **6.2. Сортировка пузырьком**

Сортировка пузырьком – один из самых известных алгоритмов сортировки. Здесь нужно последовательно сравнивать значения соседних элементов и менять числа местами, если предыдущее оказывается больше последующего. Таким образом элементы с большими значениями оказываются в конце списка, а с меньшими остаются в начале.

**Сложность по времени:**
* Худшее время: $\mathrm{O}(n^{2})$
* Среднее время: $\mathrm{O}(n^{2})$
* Лучшее время: $\mathrm{O}(n)$

**Затраты памяти:** $\mathrm{O}(1)$

```c++
template <typename T>
void BubbleSort(std::vector<T>& a)
{
    size_t n = a.size();
    for (size_t i = 0; i + 1 < n; ++i)
        for (size_t j = 0; j + 1 < n - i; ++j)
            if (a[j + 1] < a[j])
                std::swap(a[j], a[j + 1]);
}
```


### **6.3. Сортировка вставками**

При сортировке вставками массив постепенно перебирается слева направо. При этом каждый последующий элемент размещается так, чтобы он оказался между ближайшими элементами с минимальным и максимальным значением.

**Сложность по времени:**
* Худшее время: $\mathrm{O}(n^{2})$ для сравнений и перестановок
* Среднее время: $\mathrm{O}(n^{2})$ для сравнений и перестановок
* Лучшее время: $\mathrm{O}(n)$ для сравнений, $\mathrm{O}(1)$ для перестановок

**Затраты памяти:** $\mathrm{O}(n)$ основной, $\mathrm{O}(1)$ дополнительной

```c++
template <typename T>
void InsertionSort(std::vector<T>& a)
{
    size_t n = a.size();
    for (size_t i = 1; i < n; ++i)
    {
        T x = a[i];
        size_t j = i;
        while (j > 0 && a[j - 1] > x)
        {
            a[j] = a[j - 1];
            --j;
        }
        a[j] = x;
    }
}
```


### **6.4. Быстрая сортировка**

Этот алгоритм состоит из трёх шагов. Сначала из массива нужно выбрать один элемент — его обычно называют опорным. Затем другие элементы в массиве перераспределяют так, чтобы элементы меньше опорного оказались до него, а большие или равные — после. А дальше рекурсивно применяют первые два шага к подмассивам справа и слева от опорного значения.

**Сложность по времени:**
* Худшее время: $\mathrm{O}(n^{2})$
* Среднее время: $\mathrm{O}(n \log(n))$
* Лучшее время: $\mathrm{O}(n)$

**Затраты памяти:** $\mathrm{O}(n)$

```c++
template <typename T>
size_t Partition(std::vector<T>& a, size_t l, size_t r)
{
    T x = a[r];
    size_t less = l;

    for (size_t i = l; i < r; ++i)
    {
        if (a[i] <= x)
        {
            std::swap(a[i], a[less]);
            ++less;
        }
    }
    std::swap(a[less], a[r]);
    return less;
}

template <typename T>
void QuickSortImpl(std::vector<T>& a, size_t l, size_t r)
{
    if (l < r)
    {
        size_t p = Partition(a, l, r);
        QuickSortImpl(a, l, p - 1);
        QuickSortImpl(a, p + 1, r);
    }
}

template <typename T>
void QuickSort(std::vector<T>& a)
{
    if (!a.empty())
        QuickSortImpl(a, 0, a.size() - 1);
}
```


### **6.5. Сортировка слиянием**

Сортировка слиянием пригодится для таких структур данных, в которых доступ к элементам осуществляется последовательно (например, для потоков). Здесь массив разбивается на две примерно равные части и каждая из них сортируется по отдельности. Затем два отсортированных подмассива сливаются в один.

**Сложность по времени:**
* Худшее время: $\mathrm{O}(n \log(n))$
* Среднее время: $\mathrm{O}(n \log(n))$
* Лучшее время: $\mathrm{O}(n \log(n))$

**Затраты памяти:** $\mathrm{O}(n)$ вспомогательной

```c++
template <typename T>
void MergeSortImpl(std::vector<T>& a, std::vector<T>& b, size_t l, size_t r)
{
    if (l < r)
    {
        size_t m = (l + r) / 2;
        MergeSortImpl(a, b, l, m);
        MergeSortImpl(a, b, m + 1, r);

        size_t k = l;
        size_t i = l;
        size_t j = m + 1;
        for (; i <= m || j <= r;)
        {
            if (j > r || (i <= m && a[i] < a[j]))
            {
                b[k] = a[i];
                ++i;
            }
            else
            {
                b[k] = a[j];
                ++j;
            }
            ++k;
        }
        for (i = l; i <= r; ++i)
            a[i] = b[i];
    }
}

template <typename T>
void MergeSort(std::vector<T>& a)
{
    if (!a.empty())
    {
        std::vector<T> b(a.size());
        MergeSortImpl(a, b, 0, a.size() - 1);
    }
}
```

